---
title: Queue
hide_title: true
---
## `Queue`

Depending on the framework, creating a queue works a bit different.
Take a look at the sidebar to find a guide for your framework.

### `.enqueue`

```ts
async enqueue(
    payload: T,
    options: {
        id?: string;
        override?: boolean;

        runAt?: Date;
        delay?: number | string;
        repeat?: {
            every?: number | string;
            times?: number;
            cron?: string;
        }

        exclusive?: boolean;
    }
): Promise<Job<T>>
```

Enqueues a new Job and returns it.

#### Schedule for a specified date

```ts
birthdayQueue.enqueue(user.id, {
  runAt: user.birthday,
});
```

#### Delay by a week

```ts
welcomeUserQueue.enqueue(user.id, {
  delay: "7d", // same as 7 * 24 * 60 * 60 * 1000
});
```

#### Repeated job

```ts
todoReminders.enqueue(todo.id, {
  runAt: todo.scheduled_date,
  id: todo.id,
  repeat: {
    every: "1d",
    times: 3,
  },
});
```

Runs three times: At `scheduled_date`, one day later and two days later.

#### CRON Schedule

:::note Cron Jobs
This example is about *regular* Jobs, executed on a cron schedule.
If you're looking for Cron Jobs, take a look at the more idiomatic [`CronJob`](./cronjob).
:::

```ts
billingQueue.enqueue(undefined, {
  id: "billing", // makes sure job isn't duplicated
  override: true, // if another job with that ID already exists, override it
  repeat: {
    cron: "* * * * 1 *",
  },
});
```

CRON jobs are scheduled based on UTC.

#### Order Queue

```ts
orderQueue.enqueue(
    { ... },
    {
        id: "1234", // if two jobs share the same `runAt`, they're ordered by ID.
        exclusive: true, // make sure only one job is executed at once
    }
);
```

You can also specify `{ exclusive: true }` as the third argument to the `Queue` constructor.

### `.get`

```ts
*get(): AsyncIterator<Job<T>[]>
```

A generator function that can be used to iterate over pending jobs:

```ts
for await (const jobs of queue.get()) {
  // do something
}
```

### `.getById`

```ts
getById(id: string): Promise<Job<T> | null>
```

Returns a job's representation, if it exists.

### `.invoke`

```ts
invoke(id: string): Promise<Job<T> | null>
```

Gets a job and invokes it, if it exists.
Returns the job's representation.

### `.delete`

```ts
delete(id: string): Promise<Job<T> | null>
```

Gets a job and deletes it, if it exists.
Returns the job's representation.

## `Job`

A representation of a pending job.
Can be retrieved using `Queue` methods.

### `id`

```ts
id: string;
```

The job's `id`.
If not specified during `.enqueue`, it's a random UUID generated by Quirrel.

### `endpoint`

```ts
endpoint: string;
```

The HTTP endpoint the job will be executed against.
Is always the same.

### `body`

```ts
body: T;
```

The job's payload.

### `runAt`

```ts
runAt: Date;
```

The date the job is scheduled for.

### `repeat`

```ts
{
    cron?: string;
    times?: number;
    every?: number;
    count: number;
}
```

Repetition options of the job.
`count` starts at `1` and is incremented with every execution.

### `exclusive`

```ts
exclusive: boolean;
```

If a job is marked as `exclusive`, that means there won't be any other job executed at the same time.
If applied to all jobs in a queue, that effectively guarantees serial execution.

### `.invoke`

```ts
invoke(): Promise<boolean>
```

Invokes the job.
Returns `false` if it's already been executed / deleted.

### `.delete`

```ts
delete(): Promise<boolean>
```

Deletes the job.
Returns `false` if it's already been deleted / executed.
